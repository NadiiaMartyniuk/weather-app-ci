# weather-app-ci

Aby zbudować obraz dla różnych architektur, użyjemy akcji docker/setup-qemu-action (emulacja) oraz docker/setup-buildx-action (wieloplatformowy build). Przy użyciu docker/build-push-action@v6 określimy platformy linux/amd64,linux/arm64 i włączymy tryb wieloarchitektoniczny. Dodatkowo zastosujemy pamięć podręczną warstw budowania w rejestrze Docker Hub (rejestr cache). W kroku budowania ustawiamy cache-from i cache-to wskazując na publiczne repozytorium nadiiamartyniuk/cache. Używamy trybu mode=max, co pozwala zachować cache wszystkich etapów wieloetapowego budowania. ( Zródła: [docs.docker.com](https://docs.docker.com/build/ci/github-actions/cache/#:~:text=tags%3A%20user%2Fapp%3Alatest%20cache,type%3Dregistry%2Cref%3Duser%2Fapp%3Abuildcache%2Cmode%3Dmax)  oraz [blacksmith.sh](https://www.blacksmith.sh/blog/cache-is-king-a-guide-for-docker-layer-caching-in-github-actions#:~:text=Contrary%20to%20the%20,of%20options%20to%20control%20compression) )
Taki rejestr cache jest zalecany, ponieważ nie ma limitów rozmiaru jak w przypadku GitHub Cache i umożliwia ponowne użycie cache między różnymi workflow czy projektami. (Zródła: [blacksmith.sh](https://www.blacksmith.sh/blog/cache-is-king-a-guide-for-docker-layer-caching-in-github-actions#:~:text=So%E2%80%A6%20why%20is%20this%20better,the%20GitHub%20Action%E2%80%99s%20cache%20backend) oraz [blacksmith.sh](https://www.blacksmith.sh/blog/cache-is-king-a-guide-for-docker-layer-caching-in-github-actions#:~:text=Contrary%20to%20the%20,of%20options%20to%20control%20compression) )

Po zbudowaniu obrazu uruchamiamy Trivy jako krok CI. W naszym workflow używamy akcji aquasecurity/trivy-action, konfigurując ją tak, aby zakończyła działanie z kodem błędu 1 jeśli znajdzie podatności o poziomie krytycznym lub wysokim (severity: CRITICAL,HIGH, exit-code: 1). Dzięki temu cały proces CI zatrzyma się w przypadku niebezpiecznych CVE (co zapobiega wypchnięciu podatnego obrazu dalej). Gdy Trivy nie znajdzie krytycznych problemów, następuje ostatni krok publikujący obrazy. 

Ostatnim krokiem jest ponowne zbudowanie obrazu (z ponownym użyciem cache) i wypchnięcie go pod tagiem latest. W ten sposób ghcr.io/nadiiamartyniuk/REPO:latest zawsze wskazuje na najnowszą wersję aplikacji. Polityka tagowania: sha-<short_sha> zapewnia odtwarzalność (dokładnie wiemy, jaki kod został zbudowany), natomiast tag vX.Y pozwala powiązać obraz z wersją produktu. Tag latest ułatwia szybkie pobranie najnowszego obrazu do środowisk testowych lub produkcyjnych.

